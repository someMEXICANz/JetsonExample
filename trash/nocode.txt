// #include "BrainComm.h"
// using namespace std;

// namespace Brain {

// BrainComm::BrainComm(boost::asio::io_service& service, const std::string& usb_port)
//     : io_service(service)
//     , port(usb_port)
//     , running(false)
//     , connected(false)
//     , serial_port(nullptr)
//     , read_thread(nullptr)
//     , write_thread(nullptr)
//     , request_in_progress(false)
//     , request_retry_count(0)
//     , request_flags(0)
//     , response_flags(0)
//     , sendData(false)
//     , last_send_time(0)
//     , last_received_time(0)
//     , last_request_time(0)
// {
//     // Initialize positions to zero values
//     left_gps_position = {0.0, 0.0, 0.0};
//     right_gps_position = {0.0, 0.0, 0.0};
//     sister_position = {0.0, 0.0, 0.0};
//     left_gps_offset = {0.0, 0.0, 0.0};
//     right_gps_offset = {0.0, 0.0, 0.0};
    
//     // Initialize command structures
//     current_motor_command = {0.0, 0.0, 0};
//     current_control_flags = {0};
    
//     // Try to connect if port is provided
//     if (!port.empty()) {
//         initializePort();
//     }
// }

// BrainComm::~BrainComm() {
//     stop();
// }

// bool BrainComm::initializePort() 
// {
//     try {
//         serial_port = make_unique<boost::asio::serial_port>(io_service);
//         serial_port->open(port);
//         serial_port->set_option(boost::asio::serial_port_base::baud_rate(115200));
//         serial_port->set_option(boost::asio::serial_port_base::character_size(8));
//         serial_port->set_option(boost::asio::serial_port_base::stop_bits(boost::asio::serial_port_base::stop_bits::one));
//         serial_port->set_option(boost::asio::serial_port_base::parity(boost::asio::serial_port_base::parity::none));
//         serial_port->set_option(boost::asio::serial_port_base::flow_control(boost::asio::serial_port_base::flow_control::none));
        
//         connected = true;
//         stats.recordConnectionStatus(true);
//         cout << "Brain communication initialized on port " << port << endl;
//         return true;

//     } catch (const boost::system::system_error& e) 
//     {
//         stats.logError(CommError::ConnectionLost, "Failed to initialize port: " + string(e.what()));
//         connected = false;
//         return false;
//     }
// }

// bool BrainComm::start() {
//     if (running) return true;
    
//     if (!connected && !reconnect()) {
//         return false;
//     }
    
//     running = true;
//     read_thread = make_unique<thread>(&BrainComm::readThread, this);
//     write_thread = make_unique<thread>(&BrainComm::writeThread, this);
//     return true;
// }

// void BrainComm::stop() {
//     running = false;
    
//     if (read_thread && read_thread->joinable()) {
//         read_thread->join();
//     }
//     if (write_thread && write_thread->joinable()) {
//         write_thread->join();
//     }
    
//     read_thread.reset();
//     write_thread.reset();
    
//     if (serial_port && serial_port->is_open()) {
//         serial_port->close();
//     }
//     connected = false;
// }

// bool BrainComm::restart() 
// {
//     stop();
//     return start();
// }

// bool BrainComm::reconnect() {
//     if (serial_port && serial_port->is_open()) {
//         serial_port->close();
//     }
    
//     // Reset communication state
//     std::lock_guard<std::mutex> lock(state_mutex);
//     while (!pending_requests.empty()) pending_requests.pop();
//     request_in_progress = false;
//     request_retry_count = 0;
//     sendData = false;
    
//     return initializePort();
// }

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////


// void BrainComm::writeThread() 
// {
//     uint16_t request_flags_local;
//     bool sendRequest;
//     auto current_time = std::chrono::steady_clock::now();

    
                    
//     while (running) 
//     {
// 		//std::cerr << "Start of write loop" << std::endl; 
//         request_flags_local = 0;
//         sendRequest = false;
    
//         // Check if we should send a request
//         std::lock_guard<std::mutex> lock(state_mutex);
//         if (!request_in_progress && !pending_requests.empty()) 
//         {
//             request_flags_local = pending_requests.front();
//             sendRequest = true;
//             request_in_progress = true;
//             last_request_time = std::chrono::duration_cast<std::chrono::milliseconds>(
//                 std::chrono::steady_clock::now().time_since_epoch()).count();
//         }
       
//         if (sendRequest) 
//         {
//             // Send request if needed
//             std::lock_guard<std::mutex> lock(state_mutex);
//             if (!sendRequests(request_flags_local)) 
//             {
//                 // Failed to send request
//                 stats.logError(CommError::TransmissionFailed, "Failed to send request");
//             }
//         }
        
//         if (sendData) 
//         {
//             current_time = std::chrono::steady_clock::now();
//             auto current_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
//                 current_time.time_since_epoch()).count();
                
//             if (current_ms - last_send_time >= CommConstants::RESPONSE_UPDATE_PERIOD.count()) {
//                 std::lock_guard<std::mutex> lock(state_mutex);
//                 if (sendResponse(response_flags)) 
//                 {
//                     last_send_time = current_ms;
//                 }
//             }
//         }
        
//         // Check for request timeout
//         if (request_in_progress) 
//         {
//             auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
//                 std::chrono::steady_clock::now().time_since_epoch()).count();
                
//             if (now_ms - last_request_time >= CommConstants::READ_TIMEOUT.count()) 
//             {
//                 std::lock_guard<std::mutex> lock(state_mutex);
//                 // Check retry count for current request
//                 if (request_retry_count >= CommConstants::MAX_REQUEST_RETRIES)
//                 {
//                     // Max retries reached - log error and remove request
//                     char error_msg[128];
//                     snprintf(error_msg, sizeof(error_msg), 
//                              "Max retries exceeded for request 0x%04X", 
//                              pending_requests.front());
                             
//                     stats.logError(CommError::RequestTimeout, error_msg);
//                     std::cerr << "Request timed out after " 
//                               << static_cast<int>(CommConstants::MAX_REQUEST_RETRIES) 
//                               << " retries (flags: 0x" 
//                               << std::hex << pending_requests.front() << std::dec << ")" << std::endl;
                              
//                     pending_requests.pop();
//                     request_retry_count = 0;
//                     request_in_progress = false;
//                 }

//                 else 
//                 {
//                     // Retry the request
//                     request_retry_count++;
//                     request_in_progress = false;  // Allow resend on next loop
//                     std::cerr << "Retrying request (flags: 0x" 
//                               << std::hex << pending_requests.front() 
//                               << std::dec << ", attempt: " 
//                               << static_cast<int>(request_retry_count) << ")" << std::endl;
//                 }
//             }
//         }
        
//         // Sleep to avoid high CPU usage
//         std::this_thread::sleep_for(std::chrono::milliseconds(5));
//     }
// }



// // void BrainComm::readThread() 
// // {
    
// //     uint8_t buffer[CommConstants::MAX_BUFFER_SIZE];
// //     size_t buffer_index = 0;
    
// //     // Small buffer for reading one byte at a time
// //     uint8_t read_byte[1];
    
// //     while (running) 
// //     {
// // 		std::cerr << "Start of read loop" << std::endl; 
// //         // Only proceed if we're connected
// //         if (!connected || !serial_port || !serial_port->is_open()) 
// //         {
// //             std::this_thread::sleep_for(std::chrono::milliseconds(100));
// //             if (running && !connected)
// //             {
// //                 reconnect();
// //             }
// //             continue;
// //         }
        
// //         try {
// //             // Read a single byte
// //             size_t bytes_read = serial_port->read_some(boost::asio::buffer(read_byte, 1));
            
// //             if (bytes_read > 0) 
// //             {
// //                 // Add byte to buffer
// //                 buffer[buffer_index++] = read_byte[0];
                
// //                 // Process complete packet
// //                 if (buffer_index >= sizeof(RequestHeader)) 
// //                 {
// //                     // Cast buffer to header structure
// //                     RequestHeader* header = reinterpret_cast<RequestHeader*>(buffer);
// //                     size_t total_length = sizeof(RequestHeader) + header->length;
                    
// //                     // Check if we have the full packet
// //                     if (buffer_index >= total_length) 
// //                     {
// //                         // Process based on packet type
// //                         // Check if this is an acknowledgment packet (length = 1, payload is status byte)
// //                         if (header->length == 1) 
// //                         {
// //                             uint8_t* status_byte = buffer + sizeof(RequestHeader);
// //                             uint8_t status = *status_byte;
// //                             uint16_t ack_flags = header->flags;
                            
// //                             std::lock_guard<std::mutex> lock(state_mutex);
// //                             if (request_in_progress && !pending_requests.empty() && 
// //                                 pending_requests.front() == ack_flags) 
// //                             {
                                
// //                                 // Process acknowledgment
// //                                 response_flags = ack_flags;
// //                                 pending_requests.pop();
// //                                 request_in_progress = false;
// //                                 request_retry_count = 0;
// //                                 sendData = (status == 0);  // Status 0 means okay to send data
                                
// //                                 std::cerr << "Acknowledgment received for flags: 0x" 
// //                                          << std::hex << ack_flags 
// //                                          << ", status: " << static_cast<int>(status) 
// //                                          << std::dec << std::endl;
// //                             }
// //                         }
// //                         // Check if this is a request packet (no payload)
// //                         else if (header->length == 0) 
// //                         {
// //                             std::cerr << "Received request packet with flags: 0x" 
// //                                      << std::hex << header->flags << std::dec << std::endl;
                            
// //                             // Send acknowledgment (status 0 = success)
// //                             sendAcknowledgment(header->flags, 0x00);
// //                         }
// //                         // This is a data packet
// //                         else if (header->length > 1) 
// //                         {
// //                             std::cerr << "Received data packet with flags: 0x" 
// //                                      << std::hex << header->flags 
// //                                      << ", length: " << header->length << std::dec << std::endl;
                            
// //                             // Process the received data
// //                             processReceivedData(header->flags, 
// //                                                 buffer + sizeof(RequestHeader), 
// //                                                 header->length);
                            
// //                             last_received_time = std::chrono::duration_cast<std::chrono::milliseconds>(
// //                                 std::chrono::steady_clock::now().time_since_epoch()).count();
// //                         }
// //                         else 
// //                         {
// //                             stats.logError(CommError::InvalidPacket, "Invalid packet length");
// //                             std::cerr << "Received invalid packet with flags: 0x" 
// //                                      << std::hex << header->flags 
// //                                      << ", length: " << header->length << std::dec << std::endl;
// //                         }
                        
// //                         // Move any remaining data to start of buffer
// //                         if (buffer_index > total_length) 
// //                         {
// //                             memmove(buffer, buffer + total_length, buffer_index - total_length);
// //                         }
// //                         buffer_index -= total_length;
// //                     }
// //                 }
                
// //                 // Buffer overflow protection - place here at the end of the byte processing logic
// //                 if (buffer_index >= CommConstants::MAX_BUFFER_SIZE) 
// //                 {
// //                     // Log the error
// //                     stats.logError(CommError::BufferOverrun, "Receive buffer overflow");
                    
// //                     // Try to recover - look for valid packet header in the buffer
// //                     bool header_found = false;
// //                     for (size_t i = 1; i < buffer_index - sizeof(RequestHeader); i++) 
// //                     {
// //                         RequestHeader* potential_header = reinterpret_cast<RequestHeader*>(buffer + i);
// //                         // Check if this could be a valid header (simple validation)
// //                         if (potential_header->length <= CommConstants::MAX_BUFFER_SIZE - sizeof(RequestHeader)) 
// //                         {
// //                             // Found a potential valid header, shift buffer to this position
// //                             memmove(buffer, buffer + i, buffer_index - i);
// //                             buffer_index -= i;
// //                             header_found = true;
// //                             std::cerr << "Buffer overflow recovery - shifted " << i << " bytes" << std::endl;
// //                             break;
// //                         }
// //                     }
                    
// //                     // If no valid header found, discard entire buffer
// //                     if (!header_found) 
// //                     {
// //                         std::cerr << "Buffer overflow - discarded entire buffer" << std::endl;
// //                         buffer_index = 0;
// //                     }
// //                 }
// //             }
// //         }
// //         catch (const boost::system::system_error& e) 
// //         {
// //             if (running) 
// //             {   // Only log error if we're still supposed to be running
// //                 stats.logError(CommError::ReadTimeout, std::string("Read error: ") + e.what());
// //                 stats.incrementReceiveStats(false);
// //                 connected = false;
                
// //                 std::cerr << "Serial read error: " << e.what() << std::endl;
                
// //                 // Try to reconnect in the next iteration
// //                 std::this_thread::sleep_for(std::chrono::milliseconds(100));
// //             }
// //         }
        
// //         // Small sleep to prevent tight loop
// //         std::this_thread::sleep_for(std::chrono::milliseconds(1));
// //     }
// // }







// bool BrainComm::updateRequests(uint16_t flags) 
// {
//     std::lock_guard<std::mutex> lock(state_mutex);
//     pending_requests.push(flags);
//     //std::cerr << "Request queued with flags: 0x" << std::hex << flags << std::dec << std::endl;
//     return true;
// }



// bool BrainComm::sendRequests(uint16_t flags) 
// {
//     RequestHeader header;
//     header.flags = flags;
//     header.length = 0;  // No payload for requests
    
//     bool success = false;
    
//     if (serial_port && serial_port->is_open()) 
//     {
//         try 
//         {
//             // Write the header to the serial port
//             size_t written = boost::asio::write(*serial_port, 
//                                                 boost::asio::buffer(&header, sizeof(header)));
            
//             success = (written == sizeof(header));
            
//             if (success) 
//             {
//                 stats.incrementTransmitStats(true);
//                 // std::cerr << "Request sent with flags: 0x" 
//                 //           << std::hex << flags << std::dec << std::endl;
//             }
//         }
//         catch (const boost::system::system_error& e) 
//         {
//             stats.incrementTransmitStats(false);
//             stats.logError(CommError::TransmissionFailed, 
//                           "Failed to send request: " + std::string(e.what()));
//             std::cerr << "Failed to send request with flags: 0x" 
//                       << std::hex << flags << std::dec 
//                       << " error: " << e.what() << std::endl;
                      
//             connected = false;
//         }
//     }
//     else 
//     {
//         stats.incrementTransmitStats(false);
//         stats.logError(CommError::TransmissionFailed, "Serial port not open");
//         std::cerr << "Failed to send request with flags: 0x" 
//                   << std::hex << flags << std::dec 
//                   << " (port closed)" << std::endl;
                  
//         connected = false;
//     }
    
//     return success;
// }


// bool BrainComm::sendAcknowledgment(uint16_t flags, uint8_t status) {
//     // Create a header with flags and length=1
//     RequestHeader header;
//     header.flags = flags;
//     header.length = 1;  // 1 byte payload for status
    
//     bool success = false;
    
//     if (serial_port && serial_port->is_open()) {
//         try {
//             // Use scatter-gather approach for efficiency
//             std::vector<boost::asio::const_buffer> buffers;
//             buffers.push_back(boost::asio::buffer(&header, sizeof(header)));
//             buffers.push_back(boost::asio::buffer(&status, sizeof(status)));
            
//             size_t total_written = boost::asio::write(*serial_port, buffers);
//             success = (total_written == (sizeof(header) + sizeof(status)));
            
//             if (success) {
//                 stats.incrementTransmitStats(true);
//                 std::cerr << "Acknowledgment sent for flags: 0x" 
//                          << std::hex << flags << std::dec << std::endl;
//             }
//             else {
//                 stats.incrementTransmitStats(false);
//                 std::cerr << "Failed to send complete acknowledgment for flags: 0x" 
//                          << std::hex << flags << std::dec << std::endl;
//             }
//         }
//         catch (const boost::system::system_error& e) {
//             stats.incrementTransmitStats(false);
//             stats.logError(CommError::AcknowledgmentFailed, 
//                           "Failed to send acknowledgment: " + std::string(e.what()));
            
//             std::cerr << "Failed to send acknowledgment for flags: 0x" 
//                      << std::hex << flags << std::dec 
//                      << " error: " << e.what() << std::endl;
                     
//             connected = false;
//         }
//     }
//     else {
//         stats.incrementTransmitStats(false);
//         std::cerr << "Failed to send acknowledgment for flags: 0x" 
//                  << std::hex << flags << std::dec 
//                  << " (port closed)" << std::endl;
                 
//         connected = false;
//     }
    
//     return success;
// }


// bool BrainComm::processReceivedData(uint16_t flags, const uint8_t* data, uint16_t length) {
//     // Calculate expected payload size based on flags
//     size_t expected_size = 0;
//     if (flags & static_cast<uint16_t>(RequestFlag::LeftGPSData))
//         expected_size += sizeof(Position2D) * 2;  // position and offset
//     if (flags & static_cast<uint16_t>(RequestFlag::RightGPSData))
//         expected_size += sizeof(Position2D) * 2;  // position and offset
//     if (flags & static_cast<uint16_t>(RequestFlag::SisterData))
//         expected_size += sizeof(Position2D);
//     if (flags & static_cast<uint16_t>(RequestFlag::BatteryLevel))
//         expected_size += sizeof(uint32_t);
    
//     // Validate total payload size
//     if (length < expected_size) {
//         stats.logError(CommError::InvalidPacket, "Received data size mismatch");
//         std::cerr << "Data packet size mismatch. Expected: " << expected_size 
//                  << ", got: " << length << std::endl;
//         return false;
//     }
    
//     // Lock the data mutex to safely update stored values
//     std::lock_guard<std::mutex> lock(data_mutex);
    
//     size_t offset = 0;
    
//     // Process left GPS data
//     if (flags & static_cast<uint16_t>(RequestFlag::LeftGPSData)) {
//         if (offset + sizeof(Position2D) <= length) {
//             memcpy(&left_gps_position, data + offset, sizeof(Position2D));
//             offset += sizeof(Position2D);
            
//             // Get the offset data
//             if (offset + sizeof(Position2D) <= length) {
//                 memcpy(&left_gps_offset, data + offset, sizeof(Position2D));
//                 offset += sizeof(Position2D);
                
//                 // std::cerr << "Received left GPS position: (" 
//                 //          << left_gps_position.x << ", " 
//                 //          << left_gps_position.y << ", " 
//                 //          << left_gps_position.heading << ")" << std::endl;
//             }
//         }
//     }
    
//     // Process right GPS data
//     if (flags & static_cast<uint16_t>(RequestFlag::RightGPSData)) {
//         if (offset + sizeof(Position2D) <= length) {
//             memcpy(&right_gps_position, data + offset, sizeof(Position2D));
//             offset += sizeof(Position2D);
            
//             // Get the offset data
//             if (offset + sizeof(Position2D) <= length) {
//                 memcpy(&right_gps_offset, data + offset, sizeof(Position2D));
//                 offset += sizeof(Position2D);
                
//                 // std::cerr << "Received right GPS position: (" 
//                 //          << right_gps_position.x << ", " 
//                 //          << right_gps_position.y << ", " 
//                 //          << right_gps_position.heading << ")" << std::endl;
//             }
//         }
//     }
    
//     // Process sister robot data
//     if (flags & static_cast<uint16_t>(RequestFlag::SisterData)) {
//         if (offset + sizeof(Position2D) <= length) {
//             memcpy(&sister_position, data + offset, sizeof(Position2D));
//             offset += sizeof(Position2D);
            
//             // std::cerr << "Received sister position: (" 
//             //          << sister_position.x << ", " 
//             //          << sister_position.y << ", " 
//             //          << sister_position.heading << ")" << std::endl;
//         }
//     }
    
//     // Process battery level
//     if (flags & static_cast<uint16_t>(RequestFlag::BatteryLevel)) 
//     {
//         if (offset + sizeof(uint32_t) <= length) {
//             uint32_t battery_level;
//             memcpy(&battery_level, data + offset, sizeof(uint32_t));
//             offset += sizeof(uint32_t);
            
//             // std::cerr << "Received Brain battery level: " 
//             //          << battery_level << "%" << std::endl;
//         }
//     }

//     stats.incrementReceiveStats(true);
//     return true;
// }



// bool BrainComm::sendResponse(uint16_t flags) {
//     // Calculate total payload size based on active flags
//     size_t payload_size = 0;
    
//     if (flags & static_cast<uint16_t>(RequestFlag::MotorVoltages)) 
//         payload_size += sizeof(MotorCommand);
        
//     if (flags & static_cast<uint16_t>(RequestFlag::MacroControls)) 
//         payload_size += sizeof(ControlFlags);
    
//     // Prepare request header
//     RequestHeader header;
//     header.flags = flags;
//     header.length = payload_size;
    
//     // Prepare payload buffer
//     uint8_t payload[CommConstants::MAX_BUFFER_SIZE];
//     size_t offset = 0;
    
//     // Add data based on flags - lock data mutex while accessing shared data
//     {
//         std::lock_guard<std::mutex> lock(data_mutex);
        
//         // Motor voltages
//         if (flags & static_cast<uint16_t>(RequestFlag::MotorVoltages)) {
//             // Update timestamp before sending
//             current_motor_command.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
//                 std::chrono::steady_clock::now().time_since_epoch()).count();
                
//             memcpy(payload + offset, &current_motor_command, sizeof(MotorCommand));
//             offset += sizeof(MotorCommand);
//         }
        
//         // Macro controls
//         if (flags & static_cast<uint16_t>(RequestFlag::MacroControls)) {
//             memcpy(payload + offset, &current_control_flags, sizeof(ControlFlags));
//             offset += sizeof(ControlFlags);
//         }
//     }
    
//     // Send header and payload
//     bool success = false;
    
//     if (serial_port && serial_port->is_open()) {
//         try {
//             // Use scatter-gather operation for more efficient writing
//             std::vector<boost::asio::const_buffer> buffers;
//             buffers.push_back(boost::asio::buffer(&header, sizeof(header)));
            
//             if (payload_size > 0) {
//                 buffers.push_back(boost::asio::buffer(payload, payload_size));
//             }
            
//             // Record the start time for timing stats
//             auto start_time = std::chrono::steady_clock::now();
            
//             // Write the data to the serial port
//             size_t total_written = boost::asio::write(*serial_port, buffers);
            
//             // Calculate transmission time
//             auto end_time = std::chrono::steady_clock::now();
//             auto transmission_time = std::chrono::duration_cast<std::chrono::microseconds>(
//                 end_time - start_time);
            
//             // Update timing statistics
//             stats.updateTimingStats(transmission_time);
            
//             success = (total_written == (sizeof(header) + payload_size));
            
//             if (success) {
//                 // std::cerr << "Sent data packet with flags: 0x" 
//                 //           << std::hex << flags << std::dec 
//                 //           << " (" << payload_size << " bytes)" << std::endl;
//             } else {
//                 stats.logError(CommError::TransmissionFailed, 
//                               "Failed to write complete packet");
//                 std::cerr << "Failed to send complete data packet with flags: 0x" 
//                           << std::hex << flags << std::dec 
//                           << " - Wrote " << total_written << " of " 
//                           << (sizeof(header) + payload_size) << " bytes" << std::endl;
//             }
//         }
//         catch (const boost::system::system_error& e) {
//             stats.logError(CommError::TransmissionFailed, 
//                           "Error sending data: " + std::string(e.what()));
//             std::cerr << "Failed to send data packet with flags: 0x" 
//                       << std::hex << flags << std::dec 
//                       << " error: " << e.what() << std::endl;
                      
//             connected = false;
//         }
//     }
//     else {
//         stats.logError(CommError::TransmissionFailed, "Serial port not open");
//         std::cerr << "Failed to send data packet with flags: 0x" 
//                   << std::hex << flags << std::dec 
//                   << " (port closed)" << std::endl;
                  
//         connected = false;
//     }
    
//     stats.incrementTransmitStats(success);
//     return success;
// }

// void BrainComm::setMotorVoltages(float left, float right) 
// {
//     lock_guard<mutex> lock(data_mutex);
//     current_motor_command.left_voltage = left;
//     current_motor_command.right_voltage = right;
//     current_motor_command.timestamp = 
//         chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count();
// }

// void BrainComm::setMacroBits(uint32_t macro_bits) 
// {
//     lock_guard<mutex> lock(data_mutex);
//     current_control_flags.macro_bits = macro_bits;
// }

// Position2D BrainComm::getLeftGPSData() const {
//     std::lock_guard<std::mutex> lock(data_mutex);
//     return left_gps_position;
// }

// Position2D BrainComm::getRightGPSData() const {
//     std::lock_guard<std::mutex> lock(data_mutex);
//     return right_gps_position;
// }

// Position2D BrainComm::getSisterPosition() const {
//     std::lock_guard<std::mutex> lock(data_mutex);
//     return sister_position;
// }

// Position2D BrainComm::getLeftGPSOffset() const {
//     std::lock_guard<std::mutex> lock(data_mutex);
//     return left_gps_offset;
// }

// Position2D BrainComm::getRightGPSOffset() const {
//     std::lock_guard<std::mutex> lock(data_mutex);
//     return right_gps_offset;
// }

// Handler for read completion
// void BrainComm::handleRead(const boost::system::error_code& ec, std::size_t bytes_transferred) {
//     if (!running) {
//         return;
//     }
    
//     if (ec) {
//         if (ec != boost::asio::error::operation_aborted) {
//             cerr << "Read error: " << ec.message() << endl;
//             stats.logError(CommError::ReadTimeout, "Read error: " + ec.message());
//             stats.incrementReceiveStats(false);
//             connected = false;
            
//             // Try to reconnect after a delay
//             boost::asio::deadline_timer reconnect_timer(io_service);
//             reconnect_timer.expires_from_now(boost::posix_time::milliseconds(100));
//             reconnect_timer.async_wait([this](const boost::system::error_code& ec) {
//                 if (!ec && reconnect()) {
//                     startAsyncRead();
//                 }
//             });
//         }
//         return;
//     }
    
//     // Successfully read data
//     if (bytes_transferred > 0) {
// 		// std::cerr << "DEBUG: Received " << bytes_transferred << " bytes. Current buffer size: " 
//         //          << buffer_index << " + " << bytes_transferred << std::endl;
        
//         // Print the received byte(s) in hex
//         // std::cerr << "DEBUG: Raw bytes: ";
//         // for (size_t i = 0; i < bytes_transferred; i++) {
//         //     std::cerr << std::hex << std::setw(2) << std::setfill('0') 
//         //              << (int)(read_buffer[buffer_index + i]) << " ";
//         // }
//         // std::cerr << std::dec << std::endl;




//         // Increment buffer index
//         buffer_index += bytes_transferred;



// 		if (buffer_index >= sizeof(RequestHeader)) 
// 		{
//             // std::cerr << "DEBUG: Buffer contains possible header. Full buffer: ";
//             // for (size_t i = 0; i < buffer_index && i < 20; i++) { // Limit to first 20 bytes
//             //     std::cerr << std::hex << std::setw(2) << std::setfill('0') 
//             //              << (int)read_buffer[i] << " ";
//             // }
//             // std::cerr << std::dec << std::endl;
            
//             // Cast buffer to header structure and print its fields
//             RequestHeader* header = reinterpret_cast<RequestHeader*>(read_buffer.data());
//             // std::cerr << "DEBUG: Header fields - flags: 0x" << std::hex << header->flags 
//             //          << ", length: " << header->length << std::dec << std::endl;
            
//             // Validate header fields
//             if (header->length > CommConstants::MAX_BUFFER_SIZE) 
// 			{
//                 std::cerr << "DEBUG: WARNING - Suspicious header length: " << header->length << std::endl;
//             }

//             size_t total_length = sizeof(RequestHeader) + header->length;

// 			// if (buffer_index < total_length) {
//             //     std::cerr << "DEBUG: Waiting for more data. Have " << buffer_index 
//             //              << " bytes, need " << total_length << " bytes" << std::endl;
//             // }
               
            
//             // Check if we have received a complete packet
//             if (buffer_index >= total_length) {
// 				 std::cerr << "DEBUG: Complete packet received" << std::endl;
//                 // Process the packet based on type
//                 if (header->length == 1) {
//                     // This is an acknowledgment packet
//                     uint8_t* status_byte = read_buffer.data() + sizeof(RequestHeader);
//                     uint8_t status = *status_byte;
//                     uint16_t ack_flags = header->flags;
                    
//                     std::lock_guard<std::mutex> lock(state_mutex);
//                     if (request_in_progress && !pending_requests.empty() && 
//                         pending_requests.front() == ack_flags) {
//                         // Process acknowledgment
//                         request_flags = ack_flags;
//                         pending_requests.pop();
//                         request_in_progress = false;
//                         request_retry_count = 0;
//                         // sendData = (status == 0);  // Status 0 means okay to send data
                        
//                         cerr << "Acknowledgment received for flags: 0x" 
//                              << hex << ack_flags 
//                              << ", status: " << static_cast<int>(status) 
//                              << dec << endl;
//                     }
//                 } 
//                 else if (header->length == 0) {
//                     // This is a request packet without payload
//                     cerr << "Received request packet with flags: 0x" 
//                          << hex << header->flags << dec << endl;

//                     sendData = (header->flags != static_cast<uint16_t>(Brain::RequestFlag::NoData));
//                     // Send acknowledgment (status 0 = success)
//                     sendAcknowledgment(header->flags, 0x00);
//                 }
//                 else if (header->length > 1) {
//                     // This is a data packet with payload
//                     cerr << "Received data packet with flags: 0x" 
//                          << hex << header->flags 
//                          << ", length: " << header->length << dec << endl;
                    
//                     // Process the received data
//                     processReceivedData(header->flags, 
//                                        read_buffer.data() + sizeof(RequestHeader), 
//                                        header->length);
                    
//                     last_received_time = chrono::duration_cast<chrono::milliseconds>(
//                         chrono::steady_clock::now().time_since_epoch()).count();
//                 }
//                 else {
//                     stats.logError(CommError::InvalidPacket, "Invalid packet length");
//                     cerr << "Received invalid packet with flags: 0x" 
//                          << hex << header->flags 
//                          << ", length: " << header->length << dec << endl;
//                 }
                
//                 // Move any remaining data to start of buffer
//                 if (buffer_index > total_length) {
//                     memmove(read_buffer.data(), read_buffer.data() + total_length, 
//                            buffer_index - total_length);
//                 }
//                 buffer_index -= total_length;
//             }
//         }
        
//         // Check for buffer overflow
//         if (buffer_index >= CommConstants::MAX_BUFFER_SIZE) {
//             stats.logError(CommError::BufferOverrun, "Receive buffer overflow");
//             cerr << "Receive buffer overflow, discarding data" << endl;
//             buffer_index = 0;
//         }
//     }
    
//     // Start the next read operation
//     startAsyncRead();
// }

















// } // namespace brain_comm




void BrainComm::handleRead(const boost::system::error_code& ec, std::size_t bytes_transferred) 
{
    if (!running) {
        return;
    }
    
    // if (ec) {
    //     if (ec != boost::asio::error::operation_aborted) {
    //         std::cerr << "DEBUG: Read error: " << ec.message() << std::endl;
    //         stats.logError(CommError::ReadTimeout, "Read error: " + ec.message());
    //         stats.incrementReceiveStats(false);
    //         connected = false;
            
    //         // Try to reconnect after a delay
    //         boost::asio::deadline_timer reconnect_timer(io_service);
    //         reconnect_timer.expires_from_now(boost::posix_time::milliseconds(100));
    //         reconnect_timer.async_wait([this](const boost::system::error_code& ec) {
    //             if (!ec && reconnect()) {
    //                 startAsyncRead();
    //             }
    //         });
    //     }
    //     return;
    // }
    


    // Successfully read data
    if (bytes_transferred > 0) {
        // std::cerr << "DEBUG: Received " << bytes_transferred << " bytes. Buffer size now: " 
        //          << buffer_index << " + " << bytes_transferred << " = " 
        //          << (buffer_index + bytes_transferred) << std::endl;
                 
        // // Hex dump of received bytes
        // std::cerr << "DEBUG: Raw bytes: ";
        // for (size_t i = 0; i < bytes_transferred; i++) {
        //     std::cerr << std::hex << std::setw(2) << std::setfill('0') 
        //              << static_cast<int>(read_buffer[buffer_index + i]) << " ";
        // }
        // std::cerr << std::dec << std::endl;
        
        // Increment buffer index
        buffer_index += bytes_transferred;
        







        bool found_start = false;
        size_t start_pos = 0;

        // Make sure we have enough bytes to contain a full start marker
        if (buffer_index >= 2) 
        {
            for (size_t i = 0; i <= buffer_index - 2; i++) 
            {
                if (read_buffer[i] == CommConstants::START_MARKER_1 && 
                    read_buffer[i+1] == CommConstants::START_MARKER_2) 
                {
                    
                    found_start = true;
                    start_pos = i;
                    
                    // If we found a start marker not at the beginning, shift buffer
                    if (i > 0) 
                    {
                        std::cerr << "DEBUG: Found start marker at offset " << i 
                                << ", shifting buffer" << std::endl;
                        memmove(read_buffer.data(), read_buffer.data() + i, buffer_index - i);
                        buffer_index -= i;
                    }
                    
                    break;
                }
            }
        }

        // If no start marker found, keep reading
        if (!found_start) 
        {
            // Check for buffer overflow
            if (buffer_index >= CommConstants::MAX_BUFFER_SIZE - 1) 
            {
                std::cerr << "DEBUG: Buffer would overflow on next read, resetting" << std::endl;
                buffer_index = 0;
            }
            // std::cerr << "DEBUG: No start marker found, continuing to read" << std::endl;
            startAsyncRead();
            return;
        }










        // Check if we have enough data for a complete header
        if (buffer_index >= sizeof(RequestHeader)) {
            RequestHeader* header = reinterpret_cast<RequestHeader*>(read_buffer.data());
            
            // Verify start marker (redundant check, but good for safety)
            if (header->start_marker[0] != CommConstants::START_MARKER_1 || 
                header->start_marker[1] != CommConstants::START_MARKER_2) {
                std::cerr << "DEBUG: Invalid start marker in header, discarding" << std::endl;
                buffer_index = 0;
                startAsyncRead();
                return;
            }
            
            // std::cerr << "DEBUG: Header fields - type: " << static_cast<int>(header->message_type)
            //          << ", flags: 0x" << std::hex << header->flags 
            //          << ", length: " << std::dec << header->length << std::endl;
            
            // Validate header length
            if (header->length > CommConstants::MAX_BUFFER_SIZE - sizeof(RequestHeader) - sizeof(EndMarker)) {
                std::cerr << "DEBUG: Invalid message length: " << header->length << std::endl;
                buffer_index = 0;
                startAsyncRead();
                return;
            }
            
            // Calculate total message length including header and end marker
            size_t total_length = sizeof(RequestHeader) + header->length + sizeof(EndMarker);
            
            // Check if we have enough data for the complete message
            if (buffer_index >= total_length) 
            {
                // Check end marker
                EndMarker* end = reinterpret_cast<EndMarker*>(
                    read_buffer.data() + sizeof(RequestHeader) + header->length);
                    
                if (end->marker[0] != CommConstants::END_MARKER_1 || 
                    end->marker[1] != CommConstants::END_MARKER_2) {
                    std::cerr << "DEBUG: Invalid end marker, discarding" << std::endl;
                    
                    // Look for another start marker after the current one
                    for (size_t i = 2; i <= buffer_index - 2; i++) {
                        if (read_buffer[i] == CommConstants::START_MARKER_1 && 
                            read_buffer[i+1] == CommConstants::START_MARKER_2) 
                        {
                            
                            std::cerr << "DEBUG: Found another start marker at offset " << i 
                                     << ", shifting buffer" << std::endl;
                            memmove(read_buffer.data(), read_buffer.data() + i, buffer_index - i);
                            buffer_index -= i;
                            startAsyncRead();
                            return;
                        }
                    }
                    
                    // No other start marker found, discard everything
                    buffer_index = 0;
                    startAsyncRead();
                    return;
                }
                
                // Process based on message type
                MessageType msg_type = static_cast<MessageType>(header->message_type);
                uint16_t flags = header->flags;
                
                switch (msg_type) {
                    case MessageType::Request:
                        std::cerr << "DEBUG: Received request message with flags: 0x" 
                                 << std::hex << flags << std::dec << std::endl;
                        
                        // Set response flags based on what the Brain is requesting
                        response_flags = flags;
                        
                        // Now we should send data (but only if the Brain actually requested something)
                        sendData = (flags != static_cast<uint16_t>(Brain::RequestFlag::NoData));
                        
                        // Send acknowledgment (status 0 = success)
                        sendAcknowledgment(flags, 0x00);
                        break;
                        
                    case MessageType::Acknowledgment:
                        if (header->length == 1) {
                            // Get status byte
                            uint8_t* status_byte = read_buffer.data() + sizeof(RequestHeader);
                            uint8_t status = *status_byte;
                            
                            std::cerr << "DEBUG: Received acknowledgment message with flags: 0x" 
                                     << std::hex << flags << ", status: " << static_cast<int>(status) 
                                     << std::dec << std::endl;
                            
                            std::lock_guard<std::mutex> lock(state_mutex);
                            if (request_in_progress && !pending_requests.empty() && 
                                pending_requests.front() == flags) {
                                
                                // Process acknowledgment
                                request_flags = flags;  // Store what we requested
                                pending_requests.pop();
                                request_in_progress = false;
                                request_retry_count = 0;
                                
                                std::cerr << "Acknowledgment received for flags: 0x" 
                                         << std::hex << flags 
                                         << ", status: " << static_cast<int>(status) 
                                         << std::dec << std::endl;
                            }
                        } else {
                            std::cerr << "DEBUG: Invalid acknowledgment message length" << std::endl;
                        }
                        break;
                        
                    case MessageType::Response:
                        std::cerr << "DEBUG: Received response message with flags: 0x" 
                                 << std::hex << flags << std::dec 
                                 << ", length: " << header->length << std::endl;
                        
                        // Process the received data
                        processReceivedData(flags, 
                                           read_buffer.data() + sizeof(RequestHeader), 
                                           header->length);
                        
                        last_received_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                            std::chrono::steady_clock::now().time_since_epoch()).count();
                        break;
                        
                    case MessageType::Handshake:
                        std::cerr << "DEBUG: Received handshake message" << std::endl;
                        
                        // Respond to handshake with acknowledgment
                        sendAcknowledgment(0, 0x00);
                        break;
                        
                    default:
                        std::cerr << "DEBUG: Unknown message type: " 
                                 << static_cast<int>(header->message_type) << std::endl;
                        break;
                }
                
                // Move any remaining data to the start of buffer
                if (buffer_index > total_length) {
                    memmove(read_buffer.data(), read_buffer.data() + total_length, 
                           buffer_index - total_length);
                    buffer_index -= total_length;
                    
                    std::cerr << "DEBUG: Moved " << buffer_index << " remaining bytes to buffer start" << std::endl;
                } else {
                    buffer_index = 0;
                }
            } 
            else 
            {
                // std::cerr << "DEBUG: Incomplete message, have " << buffer_index 
                //          << " bytes, need " << total_length << " bytes" << std::endl;
                if (buffer_index + 1 >= CommConstants::MAX_BUFFER_SIZE) 
                {
                std::cerr << "DEBUG: Buffer would overflow on next read, resetting buffer" << std::endl;
                buffer_index = 0;
                }

            }
        }
    }
    
    // Start the next read operation
    startAsyncRead();
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Start an asynchronous write operation
bool BrainComm::startAsyncWrite(uint16_t flags, MessageType msg_type)
{
    if (!running || !connected || !serial_port || !serial_port->is_open()) {
        std::cerr << "DEBUG: Cannot start async write - connection not ready" << std::endl;
        return false;
    }
    
    // Prepare header for message
    RequestHeader header;
    header.start_marker[0] = CommConstants::START_MARKER_1;
    header.start_marker[1] = CommConstants::START_MARKER_2;
    header.message_type = static_cast<uint8_t>(msg_type);
    header.flags = flags;
    header.length = 0;  // Default to no payload
    
    // Set up end marker
    EndMarker end_marker;
    end_marker.marker[0] = CommConstants::END_MARKER_1;
    end_marker.marker[1] = CommConstants::END_MARKER_2;
    
    // Create a sequence of buffers to send
    std::vector<boost::asio::const_buffer> buffers;
    buffers.push_back(boost::asio::buffer(&header, sizeof(header)));
    
    // If we have a payload, it would be added here
    // buffers.push_back(boost::asio::buffer(payload_data, payload_size));
    
    // Add end marker
    buffers.push_back(boost::asio::buffer(&end_marker, sizeof(end_marker)));
    
    std::cerr << "DEBUG: Sending message - type: " << static_cast<int>(msg_type) 
             << ", flags: 0x" << std::hex << flags << std::dec << std::endl;
             
    // Start asynchronous write
    boost::asio::async_write(*serial_port, buffers,
        std::bind(&BrainComm::handleWrite, this,
                  std::placeholders::_1,
                  std::placeholders::_2,
                  true)  // true indicates this is a request
    );
    
    return true;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////














// Handler for write completion
void BrainComm::handleWrite(const boost::system::error_code& ec, std::size_t bytes_transferred, bool is_request) {
    if (!running) {
        return;
    }
    
    if (ec) {
        if (ec != boost::asio::error::operation_aborted) {
            cerr << "Write error: " << ec.message() << endl;
            stats.logError(CommError::TransmissionFailed, "Write error: " + ec.message());
            stats.incrementTransmitStats(false);
            connected = false;
        }
    }
    else {
        // Write succeeded
        stats.incrementTransmitStats(true);
        
        if (is_request) {
            //cerr << "Request sent successfully" << endl;
            last_request_time = chrono::duration_cast<chrono::milliseconds>(
                chrono::steady_clock::now().time_since_epoch()).count();
        }
        else {
			if(bytes_transferred > 0)
			{
            	//cerr << "Data sent successfully" << endl;
            	last_send_time = chrono::duration_cast<chrono::milliseconds>(
                chrono::steady_clock::now().time_since_epoch()).count();
			}

			else
			{
				cerr << "No Data sent successfully" << endl;
			}
		
				
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


void BrainComm::handleTimer(const boost::system::error_code& ec) {
    if (!running) {
        return;
    }
    
    if (!ec) {
        // Periodic connection check & reconnection attempts
        static uint32_t last_reconnect_attempt = 0;
        static uint32_t last_read_check = 0;
        auto current_time = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
            
        // Attempt reconnection every 2 seconds if not connected
        if (!connected && (current_time - last_reconnect_attempt >= 2000)) {
            last_reconnect_attempt = current_time;
            std::cerr << "DEBUG: Not connected to Brain, attempting to reconnect..." << std::endl;
            
            if (reconnect()) {
                std::cerr << "DEBUG: Successfully reconnected to Brain" << std::endl;
            } else {
                std::cerr << "DEBUG: Reconnection attempt failed, will try again" << std::endl;
            }
        }
        
        // Check for read operation state every 5 seconds
        if (current_time - last_read_check >= 5000) {
            last_read_check = current_time;
            
            // Use read_in_progress to see if we have an active read
            if (connected && serial_port && serial_port->is_open() && !read_in_progress.load()) {
                std::cerr << "DEBUG: No active read operation detected, restarting read" << std::endl;
                buffer_index = 0;
                startAsyncRead();
            }
        }
        
        // Regular timer operations
        checkPendingRequests();
        
        // Send periodic data if enabled
        if (sendData) {
            if (current_time - last_send_time >= CommConstants::RESPONSE_UPDATE_PERIOD.count()) {
                sendResponse(response_flags);
            }
        }
        
        // Check for request timeouts
        checkRequestTimeout();
        
        // Restart the timer
        timer.expires_from_now(boost::posix_time::milliseconds(20));
        timer.async_wait(std::bind(&BrainComm::handleTimer, this, std::placeholders::_1));
    }
    else if (ec != boost::asio::error::operation_aborted) 
    {
        std::cerr << "Timer error: " << ec.message() << std::endl;
        
        // Restart timer with a slightly longer delay
        timer.expires_from_now(boost::posix_time::milliseconds(100));
        timer.async_wait(std::bind(&BrainComm::handleTimer, this, std::placeholders::_1));
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


void BrainComm::checkPendingRequests() {
    std::lock_guard<std::mutex> lock(state_mutex);
    
    if (!request_in_progress && !pending_requests.empty()) {
        uint16_t flags = pending_requests.front();
        request_in_progress = true;
        
        // Create a copy of the flags to use after releasing the lock
        uint16_t flags_copy = flags;
        
        startAsyncWrite(flags_copy,MessageType::Request);
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


void BrainComm::checkRequestTimeout() {
    if (!request_in_progress) {
        return;
    }
    
    auto now_ms = chrono::duration_cast<chrono::milliseconds>(
        chrono::steady_clock::now().time_since_epoch()).count();
        
    if (now_ms - last_request_time >= CommConstants::READ_TIMEOUT.count()) {
        std::lock_guard<std::mutex> lock(state_mutex);
        
        // Check retry count
        if (request_retry_count >= CommConstants::MAX_REQUEST_RETRIES) {
            // Max retries reached, log error and abandon request
            string error_msg = "Request timeout after " + 
                               to_string(CommConstants::MAX_REQUEST_RETRIES) + " retries";
            stats.logError(CommError::RequestTimeout, error_msg);
            
            if (!pending_requests.empty()) {
                cerr << "Request timed out after " << CommConstants::MAX_REQUEST_RETRIES 
                     << " retries (flags: 0x" << hex << pending_requests.front() 
                     << dec << ")" << endl;
                pending_requests.pop();
            }
            
            request_retry_count = 0;
            request_in_progress = false;
        }
        else {
            // Retry the request
            request_retry_count++;
            request_in_progress = false;  // Allow resend on next timer tick
            
            if (!pending_requests.empty()) {
                cerr << "Retrying request (flags: 0x" << hex << pending_requests.front() 
                     << dec << ", attempt: " << static_cast<int>(request_retry_count) 
                     << ")" << endl;
            }
        }
    }
}



void BrainComm::handleRead(const boost::system::error_code& ec, std::size_t bytes_transferred) 
{
    if (!running) {
        return;
    }
    
    // if (ec) {
    //     if (ec != boost::asio::error::operation_aborted) {
    //         std::cerr << "DEBUG: Read error: " << ec.message() << std::endl;
    //         stats.logError(CommError::ReadTimeout, "Read error: " + ec.message());
    //         stats.incrementReceiveStats(false);
    //         connected = false;
            
    //         // Try to reconnect after a delay
    //         boost::asio::deadline_timer reconnect_timer(io_service);
    //         reconnect_timer.expires_from_now(boost::posix_time::milliseconds(100));
    //         reconnect_timer.async_wait([this](const boost::system::error_code& ec) {
    //             if (!ec && reconnect()) {
    //                 startAsyncRead();
    //             }
    //         });
    //     }
    //     return;
    // }
    


    // Successfully read data
    if (bytes_transferred > 0) {
        // std::cerr << "DEBUG: Received " << bytes_transferred << " bytes. Buffer size now: " 
        //          << buffer_index << " + " << bytes_transferred << " = " 
        //          << (buffer_index + bytes_transferred) << std::endl;
                 
        // // Hex dump of received bytes
        // std::cerr << "DEBUG: Raw bytes: ";
        // for (size_t i = 0; i < bytes_transferred; i++) {
        //     std::cerr << std::hex << std::setw(2) << std::setfill('0') 
        //              << static_cast<int>(read_buffer[buffer_index + i]) << " ";
        // }
        // std::cerr << std::dec << std::endl;
        
        // Increment buffer index
        buffer_index += bytes_transferred;
        







        bool found_start = false;
        size_t start_pos = 0;

        // Make sure we have enough bytes to contain a full start marker
        if (buffer_index >= 2) 
        {
            for (size_t i = 0; i <= buffer_index - 2; i++) 
            {
                if (read_buffer[i] == CommConstants::START_MARKER_1 && 
                    read_buffer[i+1] == CommConstants::START_MARKER_2) 
                {
                    
                    found_start = true;
                    start_pos = i;
                    
                    // If we found a start marker not at the beginning, shift buffer
                    if (i > 0) 
                    {
                        std::cerr << "DEBUG: Found start marker at offset " << i 
                                << ", shifting buffer" << std::endl;
                        memmove(read_buffer.data(), read_buffer.data() + i, buffer_index - i);
                        buffer_index -= i;
                    }
                    
                    break;
                }
            }
        }

        // If no start marker found, keep reading
        if (!found_start) 
        {
            // Check for buffer overflow
            if (buffer_index >= CommConstants::MAX_BUFFER_SIZE - 1) 
            {
                std::cerr << "DEBUG: Buffer would overflow on next read, resetting" << std::endl;
                buffer_index = 0;
            }
            // std::cerr << "DEBUG: No start marker found, continuing to read" << std::endl;
            startAsyncRead();
            return;
        }










        // Check if we have enough data for a complete header
        if (buffer_index >= sizeof(RequestHeader)) {
            RequestHeader* header = reinterpret_cast<RequestHeader*>(read_buffer.data());
            
            // Verify start marker (redundant check, but good for safety)
            if (header->start_marker[0] != CommConstants::START_MARKER_1 || 
                header->start_marker[1] != CommConstants::START_MARKER_2) {
                std::cerr << "DEBUG: Invalid start marker in header, discarding" << std::endl;
                buffer_index = 0;
                startAsyncRead();
                return;
            }
            
            // std::cerr << "DEBUG: Header fields - type: " << static_cast<int>(header->message_type)
            //          << ", flags: 0x" << std::hex << header->flags 
            //          << ", length: " << std::dec << header->length << std::endl;
            
            // Validate header length
            if (header->length > CommConstants::MAX_BUFFER_SIZE - sizeof(RequestHeader) - sizeof(EndMarker)) {
                std::cerr << "DEBUG: Invalid message length: " << header->length << std::endl;
                buffer_index = 0;
                startAsyncRead();
                return;
            }
            
            // Calculate total message length including header and end marker
            size_t total_length = sizeof(RequestHeader) + header->length + sizeof(EndMarker);
            
            // Check if we have enough data for the complete message
            if (buffer_index >= total_length) 
            {
                // Check end marker
                EndMarker* end = reinterpret_cast<EndMarker*>(
                    read_buffer.data() + sizeof(RequestHeader) + header->length);
                    
                if (end->marker[0] != CommConstants::END_MARKER_1 || 
                    end->marker[1] != CommConstants::END_MARKER_2) {
                    std::cerr << "DEBUG: Invalid end marker, discarding" << std::endl;
                    
                    // Look for another start marker after the current one
                    for (size_t i = 2; i <= buffer_index - 2; i++) {
                        if (read_buffer[i] == CommConstants::START_MARKER_1 && 
                            read_buffer[i+1] == CommConstants::START_MARKER_2) 
                        {
                            
                            std::cerr << "DEBUG: Found another start marker at offset " << i 
                                     << ", shifting buffer" << std::endl;
                            memmove(read_buffer.data(), read_buffer.data() + i, buffer_index - i);
                            buffer_index -= i;
                            startAsyncRead();
                            return;
                        }
                    }
                    
                    // No other start marker found, discard everything
                    buffer_index = 0;
                    startAsyncRead();
                    return;
                }
                
                // Process based on message type
                MessageType msg_type = static_cast<MessageType>(header->message_type);
                uint16_t flags = header->flags;
                
                switch (msg_type) {
                    case MessageType::Request:
                        std::cerr << "DEBUG: Received request message with flags: 0x" 
                                 << std::hex << flags << std::dec << std::endl;
                        
                        // Set response flags based on what the Brain is requesting
                        response_flags = flags;
                        
                        // Now we should send data (but only if the Brain actually requested something)
                        sendData = (flags != static_cast<uint16_t>(Brain::RequestFlag::NoData));
                        
                        // Send acknowledgment (status 0 = success)
                        sendAcknowledgment(flags, 0x00);
                        break;
                        
                    case MessageType::Acknowledgment:
                        if (header->length == 1) {
                            // Get status byte
                            uint8_t* status_byte = read_buffer.data() + sizeof(RequestHeader);
                            uint8_t status = *status_byte;
                            
                            std::cerr << "DEBUG: Received acknowledgment message with flags: 0x" 
                                     << std::hex << flags << ", status: " << static_cast<int>(status) 
                                     << std::dec << std::endl;
                            
                            std::lock_guard<std::mutex> lock(state_mutex);
                            if (request_in_progress && !pending_requests.empty() && 
                                pending_requests.front() == flags) {
                                
                                // Process acknowledgment
                                request_flags = flags;  // Store what we requested
                                pending_requests.pop();
                                request_in_progress = false;
                                request_retry_count = 0;
                                
                                std::cerr << "Acknowledgment received for flags: 0x" 
                                         << std::hex << flags 
                                         << ", status: " << static_cast<int>(status) 
                                         << std::dec << std::endl;
                            }
                        } else {
                            std::cerr << "DEBUG: Invalid acknowledgment message length" << std::endl;
                        }
                        break;
                        
                    case MessageType::Response:
                        std::cerr << "DEBUG: Received response message with flags: 0x" 
                                 << std::hex << flags << std::dec 
                                 << ", length: " << header->length << std::endl;
                        
                        // Process the received data
                        processReceivedData(flags, 
                                           read_buffer.data() + sizeof(RequestHeader), 
                                           header->length);
                        
                        last_received_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                            std::chrono::steady_clock::now().time_since_epoch()).count();
                        break;
                        
                    case MessageType::Handshake:
                        std::cerr << "DEBUG: Received handshake message" << std::endl;
                        
                        // Respond to handshake with acknowledgment
                        sendAcknowledgment(0, 0x00);
                        break;
                        
                    default:
                        std::cerr << "DEBUG: Unknown message type: " 
                                 << static_cast<int>(header->message_type) << std::endl;
                        break;
                }
                
                // Move any remaining data to the start of buffer
                if (buffer_index > total_length) {
                    memmove(read_buffer.data(), read_buffer.data() + total_length, 
                           buffer_index - total_length);
                    buffer_index -= total_length;
                    
                    std::cerr << "DEBUG: Moved " << buffer_index << " remaining bytes to buffer start" << std::endl;
                } else {
                    buffer_index = 0;
                }
            } 
            else 
            {
                // std::cerr << "DEBUG: Incomplete message, have " << buffer_index 
                //          << " bytes, need " << total_length << " bytes" << std::endl;
                if (buffer_index + 1 >= CommConstants::MAX_BUFFER_SIZE) 
                {
                std::cerr << "DEBUG: Buffer would overflow on next read, resetting buffer" << std::endl;
                buffer_index = 0;
                }

            }
        }
    }
    
    // Start the next read operation
    startAsyncRead();
}






void BrainComm::readLoop() {
    std::cerr << "Read thread started" << std::endl;
    
    // Buffer for reading
    std::vector<uint8_t> buffer(CommConstants::MAX_BUFFER_SIZE);
    size_t buffer_index = 0;
    
    while (running)
    {

     
        // Set up a timer for timeout
        boost::asio::deadline_timer timer(io_service);
        timer.expires_from_now(boost::posix_time::milliseconds(CommConstants::READ_TIMEOUT.count()));
        
        boost::system::error_code ec;
        size_t bytes_read = 0;
        
        // Start asynchronous read
        serial_port->async_read_some(
            boost::asio::buffer(&buffer[buffer_index], 1),
            [&](const boost::system::error_code& error, size_t bytes) {
                ec = error;
                bytes_read = bytes;
                timer.cancel(); // Cancel the timer when read completes
            }
        );
                
        // Start timer handler
        timer.async_wait([&](const boost::system::error_code& error) {
            if (!error) {
                // Timeout occurred
                serial_port->cancel(); // Cancel the ongoing read
            }
        });
                
        // Run the io_service until one operation completes
        io_service.reset();
        io_service.run_one();
                
        
        // Successfully read data
        if (bytes_read > 0) 
        {
            // Safety check for buffer overflow
            if (buffer_index + bytes_read >= CommConstants::MAX_BUFFER_SIZE) 
            {
                std::cerr << "Buffer would overflow, resetting" << std::endl;
                buffer_index = 0;
            }
                    
            // Increment buffer index
            buffer_index += bytes_read;
                    
           
            // Look for start marker
            bool found_start = false;
            size_t start_pos = 0;
                
            for (size_t i = 0; i <= buffer_index - 2; i++) 
            {
                if (buffer[i] == CommConstants::START_MARKER_1 && 
                    buffer[i+1] == CommConstants::START_MARKER_2) 
                {
                    found_start = true;
                    start_pos = i;

                    // If start marker is not at the beginning, shift buffer
                    if (i > 0) 
                    {
                        cerr << "Found start marker at offset " <<  i << ", shifting buffer" << endl; 
                        memmove(buffer.data(), buffer.data() + i, buffer_index - i);
                        buffer_index -= i;
                    }

                    break;
                }
            }


            if(!found_start && buffer_index >= CommConstants::MAX_BUFFER_SIZE)
            {
                cerr << "No start marker found, buffer full, resetting" << endl;
                buffer_index = 0;
                continue;
            }

            if(buffer_index >= sizeof(RequestHeader))
            {
                RequestHeader* header = reinterpret_cast<RequestHeader*>(buffer.data());

                if(header->start_marker[0] != CommConstants::START_MARKER_1 ||
                   header->start_marker[1] != CommConstants::START_MARKER_2)
                {
                    cerr << "Invalid start marker in header, discarding" << endl;
                    buffer_index = 0;
                    continue;
                }

                size_t total_length = sizeof(RequestHeader) + header->length + sizeof(EndMarker);


                if(buffer_index >= total_length)
                {
                    EndMarker* end = reinterpret_cast<EndMarker*> (buffer.data() + sizeof(RequestHeader) + header->length);

                    if(end->marker[0] != CommConstants::END_MARKER_1 ||
                       end->marker[1] != CommConstants::END_MARKER_2)
                    {
                        cerr << "Invalid end marker, discarding" << endl;

                        bool found_another = false;
                        for (size_t i = 0; i <= buffer_index - 2; i++) 
                        {
                            if (buffer[i] == CommConstants::START_MARKER_1 && 
                                buffer[i+1] == CommConstants::START_MARKER_2) 
                            {
                                
                                cerr << "Found another start marker at offset " <<  i << ", shifting buffer" << endl; 
                                memmove(buffer.data(), buffer.data() + i, buffer_index - i);
                                buffer_index -= i;
                                found_another = true;
                                break;
                            }

                                
                        }

                        if(!found_another)
                        {
                            buffer_index = 0;
                        }
                        continue;
                    }

                    MessageType msg_type = static_cast<MessageType>(header->message_type);
                    uint16_t flags = header->flags;

                    switch (msg_type) 
                    {
                        case MessageType::Request:
                            std::cerr << "Received request message with flags: 0x" << std::hex << flags << std::dec << std::endl;
                            stats.incrementReceiveStats(true);
                            std::lock_guard<std::mutex> lock(state_mutex);
                            response_flags = flags;
                            sendData = (flags != static_cast<uint16_t>(Brain::RequestFlag::NoData));
                
                            last_received_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                                                 std::chrono::steady_clock::now().time_since_epoch()).count();
                            std::unique_lock<std::mutex> lock(write_mutex);
                            write_condition.notify_one();
                            sendAcknowledgment(flags, 0x00);
                            break;
                    
                        case MessageType::Acknowledgment:
                            if (header->length == 1) 
                            {
                
                                uint8_t* status_byte = (buffer.data() + sizeof(RequestHeader));
                                uint8_t status = *status_byte;

                                std::cerr << "Received acknowledgment message with flags: 0x" 
                                          << std::hex << flags << ", status: " << static_cast<int>(status) 
                                          << std::dec << std::endl;
                                
                                stats.incrementReceiveStats(true);
                                std::lock_guard<std::mutex> lock(state_mutex);
                                last_received_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                                                     std::chrono::steady_clock::now().time_since_epoch()).count();
                                if (request_in_progress && !pending_requests.empty() && 
                                    pending_requests.front() == flags) 
                                {
                                    request_flags = flags; 
                                    pending_requests.pop();
                                    request_in_progress = false;
                                    request_retry_count = 0;
                                }
                            }
                 
                
                            else 
                            {
                                std::cerr << "Invalid acknowledgment message length" << std::endl;
                                stats.incrementReceiveStats(false);
    
                            }
                            break;
            
                        case MessageType::Response:
                            std::cerr << "Received response message with flags: 0x" 
                                      << std::hex << flags << std::dec 
                                      << ", length: " << header->length << std::endl;
            
           
                            processReceivedData(flags, buffer.data() + sizeof(RequestHeader), header->length);
                            break;
            
               
            
        
            
                        case MessageType::Handshake:
                            std::cerr << "Received handshake message" << std::endl;
                            stats.incrementReceiveStats(true);
                            std::lock_guard<std::mutex> lock(state_mutex);
                            last_received_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                                                 std::chrono::steady_clock::now().time_since_epoch()).count();
                            sendAcknowledgment(0, 0x00);    
                            break;
            
                        default:
                            std::cerr << "Unknown message type: " 
                                     << static_cast<int>(header->message_type) << std::endl;
                            stats.incrementReceiveStats(true);
                            break;
                    }
                    
                    // Move any remaining unprocessed data to the beginning of the buffer
                    if ( buffer_index > total_length) 
                    {
                        memmove(buffer.data(), buffer.data() + total_length, buffer_index - total_length);
                        buffer_index -= total_length;
                        cerr << " Moved " << buffer_index << " remaining bytes to buffer start" << endl;
                    } 
                    else
                    {
                        buffer_index = 0;
                    }
                }
            }
        }
        if(buffer_index >= CommConstants::MAX_BUFFER_SIZE)
        {
            cerr << "Buffer overflow in read thread" << endl;
            buffer_index = 0;
        }
    }
}





